#!/root/razer_keyboard_highlighter_venv/bin/python
import keyboard
import sys
import os
import json
import pwd
import socket
import struct
import secrets
import base64
import hmac
import psutil
import hashlib

def send_fd(sock, fd):
    """Send a file descriptor over a Unix socket"""
    sock.sendmsg([b'x'], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, struct.pack("i", fd))])

def generate_secure_socket_name():
    """Generate a cryptographically secure random socket name"""
    random_bytes = secrets.token_bytes(16)
    return base64.urlsafe_b64encode(random_bytes).decode('ascii').rstrip('=')

def get_process_info(pid):
    """Get information about a process"""
    try:
        process = psutil.Process(pid)
        return {
            'pid': pid,
            'name': process.name(),
            'exe': process.exe(),
            'cmdline': process.cmdline(),
            'username': process.username(),
            'create_time': process.create_time()
        }
    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
        return None

def verify_client_pid(conn, expected_uid):
    """Verify that the connecting process has the expected UID"""
    try:
        # Get peer credentials (SO_PEERCRED gets the credentials of the peer process)
        creds = conn.getsockopt(socket.SOL_SOCKET, socket.SO_PEERCRED, struct.calcsize('3i'))
        pid, uid, gid = struct.unpack('3i', creds)
        return pid, uid, gid
    except Exception as e:
        print(f"Error getting peer credentials: {e}")
        return None, None, None

def verify_client_process(conn, expected_username, expected_exe_hash):
    """Verify that the connecting process is the expected one using executable hash"""
    try:
        # Get peer credentials (SO_PEERCRED gets the credentials of the peer process)
        creds = conn.getsockopt(socket.SOL_SOCKET, socket.SO_PEERCRED, struct.calcsize('3i'))
        pid, uid, gid = struct.unpack('3i', creds)
        
        # Get process information
        process_info = get_process_info(pid)
        if not process_info:
            print(f"Could not get information for process {pid}")
            return False
        
        # Verify the process is running as the expected user
        if process_info['username'] != expected_username:
            print(f"Process user mismatch: {process_info['username']} != {expected_username}")
            return False
        
        # For Python processes, check the command line instead of the executable
        if expected_exe_hash:
            # Check if this is a Python process running our script
            cmdline = ' '.join(process_info['cmdline'])
            if 'razer_controller' in cmdline:
                # Calculate hash of the script file instead of the Python interpreter
                script_path = None
                for arg in process_info['cmdline']:
                    if 'razer_controller' in arg and os.path.exists(arg):
                        script_path = arg
                        break
                
                if script_path:
                    with open(script_path, 'rb') as f:
                        exe_data = f.read()
                        actual_hash = hashlib.sha256(exe_data).hexdigest()
                    
                    if actual_hash != expected_exe_hash:
                        print(f"Script hash mismatch: {actual_hash} != {expected_exe_hash}")
                        return False
                else:
                    print("Could not find script path in command line")
                    return False
            else:
                print(f"Process is not running the expected script: {cmdline}")
                return False
        
        print(f"Connection from valid process: {process_info['name']} (PID: {pid})")
        print(f"Command line: {' '.join(process_info['cmdline'])}")
        return True
        
    except Exception as e:
        print(f"Error verifying client process: {e}")
        return False

def authenticate_client(conn, expected_token):
    """Simple challenge-response authentication"""
    try:
        # Generate a random challenge
        challenge = secrets.token_bytes(16)
        conn.send(challenge)
        
        # Expect HMAC response
        response = conn.recv(32)
        if not response or len(response) != 32:
            return False
        
        # Verify the response
        expected_response = hmac.new(expected_token, challenge, 'sha256').digest()
        
        return hmac.compare_digest(response, expected_response)
    except Exception as e:
        print(f"Authentication error: {e}")
        return False

def get_executable_hash(executable_path):
    """Calculate SHA256 hash of an executable"""
    try:
        with open(executable_path, 'rb') as f:
            exe_data = f.read()
            return hashlib.sha256(exe_data).hexdigest()
    except Exception as e:
        print(f"Error calculating executable hash: {e}")
        return None

def main():
    if len(sys.argv) < 2:
        print("Usage: python keyboard_listener.py <username>")
        sys.exit(1)
    
    user_name = sys.argv[1]
    
    try:
        user_info = pwd.getpwnam(user_name)
        uid = user_info.pw_uid
        gid = user_info.pw_gid
        
        # Calculate hash of the expected executable
        expected_exe_hash = get_executable_hash("/usr/bin/razer_controller")
        if not expected_exe_hash:
            print("Failed to calculate hash for /usr/bin/razer_controller")
            sys.exit(1)
        
        print(f"Expected executable hash: {expected_exe_hash}")
        
        # Create an anonymous pipe (not a named pipe/FIFO)
        read_fd, write_fd = os.pipe()
        
        # Generate secure values
        socket_name = generate_secure_socket_name()
        auth_token = secrets.token_bytes(32)  # 256-bit token
        
        abstract_name = f"\0razer_keyboard_{socket_name}"
        
        # Create and bind the control socket
        control_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        control_socket.bind(abstract_name)
        control_socket.listen(1)
        
        print("Control socket created with secure name")
        
        # Write socket info to a protected file for the user process
        socket_info_dir = f"/run/user/{uid}/razer-keyboard"
        os.makedirs(socket_info_dir, exist_ok=True)
        os.chown(socket_info_dir, uid, gid)
        os.chmod(socket_info_dir, 0o700)
        
        socket_info_file = os.path.join(socket_info_dir, "socket_info")
        with open(socket_info_file, 'w') as f:
            # Write socket name, auth token, and expected executable hash
            f.write(f"{socket_name}\n{auth_token.hex()}\n{expected_exe_hash}")
        os.chown(socket_info_file, uid, gid)
        os.chmod(socket_info_file, 0o600)
        
        # Set up a cleanup handler
        def cleanup():
            try:
                if os.path.exists(socket_info_file):
                    os.remove(socket_info_file)
                control_socket.close()
            except:
                pass
        
        import atexit
        atexit.register(cleanup)
        
        # Accept connection from user process
        print("Waiting for user process to connect...")
        conn, addr = control_socket.accept()
        print("Client connected")
        
        # Verify client process using executable hash
        if not verify_client_process(conn, user_name, expected_exe_hash):
            print("Connection from invalid process. Rejecting.")
            conn.close()
            sys.exit(1)
        
        # Verify client PID
        client_pid, client_uid, client_gid = verify_client_pid(conn, uid)
        if client_uid != uid:
            print(f"Security alert: Connection from different UID (expected {uid}, got {client_uid})")
            conn.close()
            sys.exit(1)
        
        # Authenticate client
        if not authenticate_client(conn, auth_token):
            print("Authentication failed. Closing connection.")
            conn.close()
            sys.exit(1)
        
        print("Client authenticated successfully")
        
        # Send the read end of the pipe to the user process
        send_fd(conn, read_fd)
        conn.close()
        
        # Close our copy of the read end (the user process now has it)
        os.close(read_fd)
        
        # Close the control socket to prevent further connections
        control_socket.close()
        
        # Remove the socket info file to prevent further connection attempts
        if os.path.exists(socket_info_file):
            os.remove(socket_info_file)
        
        # Open the write end as a file object
        with os.fdopen(write_fd, 'w') as pipe:
            def send_event(event_type, key_name):
                data = {"type": event_type, "key": key_name}
                pipe.write(json.dumps(data) + '\n')
                pipe.flush()
            
            keyboard.hook(lambda e: send_event(
                'press' if e.event_type == keyboard.KEY_DOWN else 'release',
                e.name
            ))
            
            # Keep the process running
            try:
                keyboard.wait()
            except KeyboardInterrupt:
                print("Exiting...")
            finally:
                cleanup()
            
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
