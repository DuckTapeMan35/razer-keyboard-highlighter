#!/usr/bin/env python
import logging
from openrazer.client import DeviceManager
import threading
import time
import yaml
import os
import re
import traceback
import json
from collections import deque
from typing import Dict, List, Tuple, Any
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import subprocess
import select
import socket
import struct
import hmac
import binascii
import sys
import hashlib

# Conditionally import i3ipc only if needed
try:
    import i3ipc
    I3_AVAILABLE = True
except ImportError:
    I3_AVAILABLE = False

# Create a memory-efficient logger formatter
class MemoryEfficientFormatter(logging.Formatter):
    def format(self, record):
        # Use a simpler format for most messages
        if record.levelno <= logging.INFO:
            return f"{record.getMessage()}"
        else:
            # More detailed format for warnings and errors
            return f"{record.name} - {record.levelname} - {record.getMessage()}"
            
# Update your setup_logger function
def setup_logger(level=logging.INFO):
    # Create log directory if it doesn't exist
    log_dir = os.path.expanduser('~/.config/razer-keyboard-highlighter')
    os.makedirs(log_dir, exist_ok=True)
    log_file = os.path.join(log_dir, 'logs.txt')
    
    logger = logging.getLogger('razer_keyboard_highlighter')
    logger.setLevel(level)
    
    # Create memory-efficient formatter
    formatter = MemoryEfficientFormatter('%(asctime)s - %(message)s')
    
    # Create file handler
    fh = logging.FileHandler(log_file)
    fh.setLevel(level)
    fh.setFormatter(formatter)
    
    # Create console handler
    ch = logging.StreamHandler()
    ch.setLevel(level)
    ch.setFormatter(formatter)
    
    # Add handlers to logger
    logger.addHandler(fh)
    logger.addHandler(ch)
    
    return logger

# Initialize with default level, will be updated after config load
logger = setup_logger()

class PywalFileHandler(FileSystemEventHandler):
    """Handles pywal color file changes"""
    def __init__(self, callback):
        super().__init__()
        self.callback = callback
    
    def on_modified(self, event):
        if event.src_path.endswith('colors'):
            self.callback()

class ConfigFileHandler(FileSystemEventHandler):
    """Handles config file changes"""
    def __init__(self, callback):
        super().__init__()
        self.callback = callback
    
    def on_modified(self, event):
        if event.src_path.endswith('config.yaml'):
            self.callback()

class KeyboardController:
    __slots__ = [
        'config', 'device_manager', 'razer_keyboard', 'rows', 'cols',
        'key_positions', 'wm_type', 'pressed_keys', 'colors_lock',
        'colors', 'key_listener', 'wm_thread', 'pywal_updated',
        'config_updated', 'pywal_watchdog_observer', 'config_watchdog_observer',
        'current_mode', 'modifier_keys', 'pipe_fd', 'wm_integration_enabled',
        'wm_lock', 'current_key_states', 'need_redraw', 'last_non_empty_workspaces',
        'pipe_thread', 'redraw_count', 'skip_count', '_string_cache'
    ]

    def __init__(self):
        try:
            # Initialize with error handling
            logger.info("Initializing keyboard controller...")
            
            # Load configuration first
            self.config = self.load_config()

            self._string_cache = {}
            
            # Set log level based on config
            log_level = self.config.get('log_level', 'INFO').upper()
            numeric_level = getattr(logging, log_level, logging.INFO)
            
            # Update logger level
            for handler in logger.handlers:
                handler.setLevel(numeric_level)
            logger.setLevel(numeric_level)
            
            logger.info(f"Log level set to: {log_level}")
            
            # Initialize device manager and find keyboard
            self.device_manager = DeviceManager()
            logger.info("Device manager created")
            self.razer_keyboard = self.find_keyboard()
            
            if not self.razer_keyboard:
                raise RuntimeError("Razer keyboard not found")
            
            # Get keyboard dimensions as integers
            self.rows = int(self.razer_keyboard.fx.advanced.rows)
            self.cols = int(self.razer_keyboard.fx.advanced.cols)
            logger.info(f"Keyboard dimensions: {self.rows} rows x {self.cols} cols")
            
            # Parse key positions
            self.key_positions = self.parse_key_positions()
            logger.info(f"Loaded key positions for: {', '.join(self.key_positions.keys())}")
            
            # Get window manager type from config
            self.wm_type = self.config.get('window_manager', 'i3').lower()  # Default to i3
            if self.wm_type not in ['sway', 'i3', 'hyprland']:
                logger.warning(f"Invalid window manager '{self.wm_type}'. Defaulting to 'i3'")
                self.wm_type = 'i3'
                
            logger.info(f"Using window manager: {self.wm_type}")
            
            # Initialize other components
            self.pressed_keys = deque()  # Track keys in press order
            self.colors_lock = threading.Lock()
            self.colors = self.load_colors()
            self.key_listener = None
            self.wm_thread = None
            self.pywal_updated = False
            self.config_updated = False
            self.pywal_watchdog_observer = None
            self.config_watchdog_observer = None
            self.current_mode = "base"
            
            # Define modifier keys
            self.modifier_keys = {
                'super': ['windows', 'cmd', 'super'],
                'shift': ['shift'],
                'alt': ['alt', 'alt gr'],
                'ctrl': ['ctrl', 'control']
            }
            
            # Use FD passing instead of named pipes
            self.pipe_fd = None
            
            # Check if workspace integration is needed
            self.wm_integration_enabled = self.config.get('workspaces', False) or self.needs_wm_integration()
            logger.info(f"Workspace integration: {'ENABLED' if self.wm_integration_enabled else 'DISABLED'}")
            
            # Create lock only if workspace integration is enabled
            if self.wm_integration_enabled:
                self.wm_lock = threading.Lock()
            else:
                self.wm_lock = None
            
            # Ensure base mode is defined
            if 'modes' not in self.config:
                self.config['modes'] = {}
            if 'base' not in self.config['modes']:
                self.config['modes']['base'] = {'rules': [{'keys': ['all'], 'color': '(0,255,0)'}]}
            
            # Track current state for optimization
            self.current_key_states = [[(0, 0, 0) for _ in range(self.cols)] for _ in range(self.rows)]
            self.need_redraw = False
            self.last_non_empty_workspaces = set()
            
            logger.info("Keyboard controller initialized successfully")
            
        except Exception as e:
            logger.error(f"Initialization failed: {e}")
            logger.error(traceback.format_exc())
            raise

    def get_cached_string(self, s):
        """Get a cached version of a string to avoid duplication"""
        if s not in self._string_cache:
            self._string_cache[s] = s
        return self._string_cache[s]

    def needs_wm_integration(self) -> bool:
        """Check if any rules require workspace information"""
        for mode_name, mode_config in self.config.get('modes', {}).items():
            for rule in mode_config.get('rules', []):
                if rule.get('condition') == 'non_empty_workspaces':
                    return True
        return False

    def load_config(self) -> Dict[str, Any]:
        """Load YAML configuration from script directory"""
        try:
            # Get config file
            script_dir = os.path.expanduser('~/.config/razer-keyboard-highlighter')
            config_path = os.path.join(script_dir, 'config.yaml')
            logger.info(f"Loading config from: {config_path}")
            
            if not os.path.exists(config_path):
                logger.info("Config file not found, using default configuration")
                return {
                    'pywal': True,
                    'workspaces': False,
                    'key_positions': {},
                    'log_level': 'INFO',  # Default log level
                    'modes': {
                        'base': {
                            'rules': [
                                {'keys': ['all'], 'color': '(0,255,0)'}
                            ]
                        }
                    }
                }
            
            with open(config_path, 'r') as f:
                config = yaml.safe_load(f)
                
                # Set defaults if not present
                config.setdefault('pywal', False)
                config.setdefault('workspaces', False)
                config.setdefault('log_level', 'INFO')  # Default log level
                
                logger.info("Config loaded successfully")
                return config
                
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            logger.error(traceback.format_exc())
            return {}

    def parse_key_positions(self) -> Dict[str, List[Tuple[int, int]]]:
        """Parse key positions from config, with memory optimization"""
        positions = {}
        
        # Create 'all' key group using actual keyboard dimensions
        positions['all'] = [(r, c) for r in range(self.rows) for c in range(self.cols)]
        
        # Load positions from config
        if 'key_positions' in self.config:
            for key, value in self.config['key_positions'].items():
                try:
                    # Intern the key name to reduce duplication
                    interned_key = sys.intern(key)
                    
                    if isinstance(value, list):
                        # Convert all elements to (int, int)
                        converted = []
                        for item in value:
                            if isinstance(item, (list, tuple)) and len(item) == 2:
                                converted.append((int(item[0]), int(item[1])))
                            elif isinstance(item, str) and item.startswith('(') and item.endswith(')'):
                                # Safely parse string tuple
                                try:
                                    # Remove parentheses and split
                                    stripped = item.strip()[1:-1]
                                    parts = stripped.split(',')
                                    if len(parts) == 2:
                                        row = int(parts[0].strip())
                                        col = int(parts[1].strip())
                                        converted.append((row, col))
                                    else:
                                        logger.warning(f"Invalid tuple format for key '{interned_key}': {item}")
                                except ValueError as e:
                                    logger.warning(f"Error parsing position '{item}' for key '{interned_key}': {e}")
                            else:
                                logger.warning(f"Invalid position format for key '{interned_key}': {item}")
                        positions[interned_key] = converted
                    elif isinstance(value, (tuple, list)) and len(value) == 2:
                        # Single position
                        positions[interned_key] = [(int(value[0]), int(value[1]))]
                    else:
                        logger.warning(f"Invalid position format for key '{interned_key}': {value}")
                        positions[interned_key] = []
                except Exception as e:
                    logger.warning(f"Error parsing position for key '{key}': {e}")
                    positions[sys.intern(key)] = []
        
        # Add default positions for essential keys as integers
        defaults = {
            'super': [(5, 1)],
            'enter': [(3, 13)],
            'numbers': [(1,1), (1,2), (1,3), (1,4), (1,5), (1,6), (1,7), (1,8), (1,9), (1,10)],
            'arrows': [(5,14), (5,15), (5,16), (4,15)],
            'shift': [(4,0)],
            'alt': [(5,2)],
            'ctrl': [(5,0)],
            'q': [(2,1)],
            'd': [(3,3)],
            'x': [(4,3)],
            'z': [(4,2)],
            'space': [(5,7)],
            'tab': [(2,0)],
            'esc': [(1,0)],
            'backspace': [(1,15)],
        }
        
        for key, pos_list in defaults.items():
            if key not in positions:
                # Convert to list of integer tuples and intern the key
                interned_key = sys.intern(key)
                positions[interned_key] = [(int(r), int(c)) for r, c in pos_list]
                logger.info(f"Added default position for key '{interned_key}'")
        
        # Ensure all positions are integers
        for key in list(positions.keys()):
            new_list = []
            for pos in positions[key]:
                if isinstance(pos, (tuple, list)) and len(pos) == 2:
                    new_list.append((int(pos[0]), int(pos[1])))
            positions[key] = new_list
        
        return positions

    def find_keyboard(self):
        """Find Razer keyboard device by VID/PID"""
        logger.info("Searching for Razer keyboards by VID/PID...")
        
        # List of known Razer keyboard VID/PID combinations
        razer_keyboards = {
            "1532:010D", "1532:010E", "1532:010F", "1532:0118", "1532:011A",
            "1532:011B", "1532:011C", "1532:0202", "1532:0203", "1532:0204",
            "1532:0205", "1532:0209", "1532:020F", "1532:0210", "1532:0211",
            "1532:0214", "1532:0216", "1532:0217", "1532:021A", "1532:021E",
            "1532:021F", "1532:0220", "1532:0221", "1532:0224", "1532:0225",
            "1532:0226", "1532:0227", "1532:0228", "1532:022A", "1532:022C",
            "1532:022D", "1532:022F", "1532:0232", "1532:0233", "1532:0234",
            "1532:0235", "1532:0237", "1532:0239", "1532:023A", "1532:023B",
            "1532:023F", "1532:0240", "1532:0241", "1532:0243", "1532:0245",
            "1532:0246", "1532:024A", "1532:024B", "1532:024C", "1532:024D",
            "1532:024E", "1532:0252", "1532:0253", "1532:0255", "1532:0256",
            "1532:0257", "1532:0258", "1532:0259", "1532:025A", "1532:025C",
            "1532:025D", "1532:025E", "1532:0266", "1532:0268", "1532:0269",
            "1532:026A", "1532:026B", "1532:026C", "1532:026D", "1532:026E",
            "1532:026F", "1532:0270", "1532:0271", "1532:0276", "1532:0279",
            "1532:027A", "1532:0282", "1532:0287", "1532:028A", "1532:028B",
            "1532:028C", "1532:028D", "1532:028F", "1532:0290", "1532:0292",
            "1532:0293", "1532:0294", "1532:0295", "1532:0296", "1532:0298",
            "1532:029D", "1532:029E", "1532:029F", "1532:02A0", "1532:02A1",
            "1532:02A2", "1532:02A3", "1532:02A5", "1532:02A6", "1532:02B6",
            "1532:02B8", "1532:0A24"
        }
        
        for device in self.device_manager.devices:
            # Format VID/PID as "vid:pid" string
            vidpid = f"{device._vid:04X}:{device._pid:04X}"
            logger.debug(f"Checking device: {device.name} (VID:PID={vidpid})")
            
            if vidpid in razer_keyboards:
                logger.info(f"Using keyboard: {device.name} (VID:PID={vidpid})")
                return device
        logger.warning("No Razer keyboard found with known VID/PID")
        return None

    def load_colors(self) -> List[Tuple[int, int, int]]:
        """Load colors from pywal or use defaults"""
        if self.config.get('pywal', True):
            colors = self.read_wal_colors('/home/duck/.cache/wal/colors')
            if colors:
                logger.info(f"Loaded {len(colors)} colors from pywal")
                return colors
            else:
                logger.info("Using fallback colors")
                return [
                    (55, 59, 67),    # Background
                    (171, 178, 191),  # Foreground
                    (191, 97, 106),   # Red
                    (163, 190, 140),  # Green
                    (224, 175, 104),  # Yellow
                    (129, 162, 190),  # Blue
                    (180, 142, 173),  # Magenta
                    (139, 213, 202),  # Cyan
                    (92, 99, 112)     # Light gray
                ]
        else:
            logger.info("Pywal disabled, using default colors")
            return [
                (100, 100, 100),  # Default color
                (200, 200, 200)   # Highlight color
            ]

    def read_wal_colors(self, file_path: str) -> List[Tuple[int, int, int]]:
        """Read colors from pywal cache file"""
        try:
            rgb_colors = []
            if not os.path.exists(file_path):
                logger.warning(f"Wal colors file not found at {file_path}")
                return []
                
            with open(file_path, 'r') as file:
                for line in file:
                    cleaned = line.strip()
                    if not cleaned:
                        continue
                    hex_color = cleaned.lstrip('#').strip()
                    if len(hex_color) == 6:
                        r = int(hex_color[0:2], 16)
                        g = int(hex_color[2:4], 16)
                        b = int(hex_color[4:6], 16)
                        rgb_colors.append((r, g, b))
            return rgb_colors
        except Exception as e:
            logger.error(f"Error reading wal colors: {e}")
            return []

    def resolve_color(self, color_spec: Any) -> Tuple[int, int, int]:
        """Convert color specification to RGB tuple"""
        try:
            # Handle RGB list
            if isinstance(color_spec, list) and len(color_spec) == 3:
                return tuple(color_spec)
            
            # Handle string specifications
            if isinstance(color_spec, str):
                # Handle color[n] specification
                match = re.match(r'color\[(\d+)\]', color_spec)
                if match:
                    idx = int(match.group(1))
                    if idx < len(self.colors):
                        return self.colors[idx]
                
                # Handle hex colors
                elif color_spec.startswith('#'):
                    hex_color = color_spec[1:]
                    if len(hex_color) == 6:
                        r = int(hex_color[0:2], 16)
                        g = int(hex_color[2:4], 16)
                        b = int(hex_color[4:6], 16)
                        return (r, g, b)
        except Exception as e:
            logger.error(f"Error resolving color {color_spec}: {e}")
        
        return (0, 0, 0)  # Default to black

    def get_hyprland_workspaces(self):
        """Get list of non-empty workspaces from Hyprland"""
        try:
            # Use hyprctl to get workspace info
            result = subprocess.run(
                ['hyprctl', 'workspaces', '-j'],
                capture_output=True,
                text=True,
                timeout=1.0
            )
            workspaces = json.loads(result.stdout)
            
            non_empty = []
            for ws in workspaces:
                if ws['windows'] > 0:
                    # Only consider workspaces with IDs 1-10 for keyboard highlighting
                    if 1 <= ws['id'] <= 10:
                        non_empty.append(str(ws['id']))
            return non_empty
        except Exception as e:
            logger.error(f"Error getting Hyprland workspaces: {e}")
            return []

    def get_i3_or_sway_workspaces(self):
        """Get list of non-empty workspaces from i3/sway"""
        try:
            i3 = i3ipc.Connection()
            workspaces = i3.get_workspaces()
            tree = i3.get_tree()
            workspace_names = []

            for ws in workspaces:
                if ws.name == "__i3_scratch":
                    continue
                for container in tree.workspaces():
                    if container.name == ws.name:
                        if container.leaves():
                            workspace_names.append(ws.name)
                        break
            return workspace_names
        except Exception as e:
            logger.error(f"Error getting i3/sway workspaces: {e}")
            return []

    def find_non_empty_workspaces(self):
        """Get list of non-empty workspaces from the configured WM"""
        if not self.wm_integration_enabled:
            return []
            
        try:
            if (self.wm_type == 'i3' or self.wm_type == 'sway') and I3_AVAILABLE:
                return self.get_i3_or_sway_workspaces()
            elif self.wm_type == 'hyprland':
                return self.get_hyprland_workspaces()
                
        except Exception as e:
            logger.error(f"Error getting workspaces: {e}")
        return []

    def update_workspaces(self):
        """Update workspace status (only if integration enabled)"""
        if not self.wm_integration_enabled:
            return
            
        if self.wm_lock:
            with self.wm_lock:
                try:
                    current_workspaces = set(self.find_non_empty_workspaces())
                    # Only mark for redraw if workspaces have changed
                    if current_workspaces != self.last_non_empty_workspaces:
                        self.last_non_empty_workspaces = current_workspaces
                        self.need_redraw = True
                        logger.info(f"Workspaces changed: {current_workspaces}")
                except Exception as e:
                    logger.error(f"Error updating workspaces: {e}")
        else:
            try:
                current_workspaces = set(self.find_non_empty_workspaces())
                # Only mark for redraw if workspaces have changed
                if current_workspaces != self.last_non_empty_workspaces:
                    self.last_non_empty_workspaces = current_workspaces
                    self.need_redraw = True
                    logger.info(f"Workspaces changed: {current_workspaces}")
            except Exception as e:
                logger.error(f"Error updating workspaces: {e}")

    def reload_config(self):
        """Reload configuration from file"""
        with self.colors_lock:
            try:
                self.config = self.load_config()
                self.key_positions = self.parse_key_positions()
                self.colors = self.load_colors()
                
                # Update log level if changed
                log_level = self.config.get('log_level', 'INFO').upper()
                numeric_level = getattr(logging, log_level, logging.INFO)
                
                # Update logger level
                for handler in logger.handlers:
                    handler.setLevel(numeric_level)
                logger.setLevel(numeric_level)
                logger.info(f"Log level updated to: {log_level}")
                
                # Re-evaluate workspace requirement
                self.wm_type = self.config.get('window_manager', 'i3').lower()
                self.wm_integration_enabled = self.config.get('workspaces', False) or self.needs_wm_integration()
                logger.info(f"Workspace integration: {'ENABLED' if self.wm_integration_enabled else 'DISABLED'}")
                logger.info("Configuration reloaded")

                self.config_updated = False
                # Force redraw after config reload
                self.need_redraw = True
                # Update lighting after reload
                self.update_lighting()
            except Exception as e:
                logger.error(f"Error reloading config: {e}")

    def get_keys_positions(self, key_spec: Any) -> List[Tuple[int, int]]:
        """Get positions for a key or key group"""
        try:
            if isinstance(key_spec, str):
                return self.key_positions.get(key_spec, [])
            elif isinstance(key_spec, list):
                positions = []
                for k in key_spec:
                    positions.extend(self.get_keys_positions(k))
                return positions
        except Exception as e:
            logger.error(f"Error getting positions for {key_spec}: {e}")
        return []

    def apply_rule(self, rule: Dict[str, Any], desired_state: Dict[Tuple[int, int], Tuple[int, int, int]]):
        """Apply a lighting rule to the desired state"""
        try:
            # Get key positions
            keys = rule.get('keys', [])
            positions = self.get_keys_positions(keys)
            if not positions:
                logger.warning(f"No positions found for keys: {keys}")
                return
            
            # Handle per-key colors
            if 'colors' in rule:
                logger.info(f"Applying per-key colors for {keys}")
                colors = [self.resolve_color(c) for c in rule['colors']]
                for i, pos in enumerate(positions):
                    try:
                        row = int(pos[0])
                        col = int(pos[1])
                        if i < len(colors):
                            desired_state[(row, col)] = colors[i]
                    except (ValueError, TypeError):
                        continue
            
            # Handle conditional rules
            condition = rule.get('condition')
            if condition == 'non_empty_workspaces':
                # Skip if workspace integration not enabled
                if not self.wm_integration_enabled:
                    logger.info("Skipping workspace condition - integration disabled")
                    return
                    
                value = rule.get('value')
                color = self.resolve_color(rule.get('color'))
                logger.info(f"Applying condition for {keys}: non_empty={value}")
                
                # Only apply to number keys
                if keys == ['numbers']:
                    for i, pos in enumerate(positions):
                        try:
                            row = int(pos[0])
                            col = int(pos[1])
                            workspace_num = str(i + 1)
                            if (workspace_num in self.last_non_empty_workspaces) == value:
                                desired_state[(row, col)] = color
                        except (ValueError, TypeError):
                            continue
                return
            
            # Handle simple color rule
            if 'color' in rule:
                color = self.resolve_color(rule['color'])
                logger.debug(f"Setting {keys} to {color}")
                for pos in positions:
                    try:
                        row = int(pos[0])
                        col = int(pos[1])
                        desired_state[(row, col)] = color
                    except (ValueError, TypeError):
                        continue
        except Exception as e:
            logger.error(f"Error applying rule: {e}")
            logger.error(traceback.format_exc())

    def normalize_key_str(self, key_name: str) -> str:
        """Normalize key name string with memory optimization"""
        name = key_name.lower()
        
        # Define a set of common keys for interning
        common_keys = {
            'super', 'shift', 'alt', 'ctrl', 'enter', 'space', 'tab', 
            'esc', 'escape', 'backspace', 'up', 'down', 'left', 'right',
            'windows', 'cmd', 'control', 'alt gr', '`', '~', '!', '@',
            '#', '$', '%', '^', '&', '*', '(', ')', '-', '_', '=', '+',
            '[', ']', '{', '}', '\\', '|', ';', ':', "'", '"', ',', '<',
            '.', '>', '/', '?', 'backtick', 'tilde', 'exclamation', 'at',
            'hash', 'dollar', 'percent', 'caret', 'ampersand', 'asterisk',
            'paren_left', 'paren_right', 'minus', 'underscore', 'equal',
            'plus', 'bracket_left', 'bracket_right', 'brace_left', 'brace_right',
            'backslash', 'pipe', 'semicolon', 'colon', 'apostrophe', 'quote',
            'comma', 'less', 'period', 'greater', 'slash', 'question'
        }
        
        # Handle modifier keys
        for mod, aliases in self.modifier_keys.items():
            if name in aliases:
                return sys.intern(mod)
        
        # Handle special keys
        special_keys = {
            'enter': 'enter',
            'space': 'space',
            'tab': 'tab',
            'esc': 'esc',
            'escape': 'esc',
            'backspace': 'backspace',
            'up': 'up',
            'down': 'down',
            'left': 'left',
            'right': 'right',
            '`': 'backtick',
            '~': 'tilde',
            '!': 'exclamation',
            '@': 'at',
            '#': 'hash',
            '$': 'dollar',
            '%': 'percent',
            '^': 'caret',
            '&': 'ampersand',
            '*': 'asterisk',
            '(': 'paren_left',
            ')': 'paren_right',
            '-': 'minus',
            '_': 'underscore',
            '=': 'equal',
            '+': 'plus',
            '[': 'bracket_left',
            ']': 'bracket_right',
            '{': 'brace_left',
            '}': 'brace_right',
            '\\': 'backslash',
            '|': 'pipe',
            ';': 'semicolon',
            ':': 'colon',
            "'": 'apostrophe',
            '"': 'quote',
            ',': 'comma',
            '<': 'less',
            '.': 'period',
            '>': 'greater',
            '/': 'slash',
            '?': 'question'
        }
        
        # Handle number keys
        if name.isdigit():
            return sys.intern(name) if name in common_keys else name
        
        # Handle letter keys
        if len(name) == 1:
            normalized = name.lower()
            return sys.intern(normalized) if normalized in common_keys else normalized
        
        # Return special key if found, otherwise return original
        if name in special_keys:
            result = special_keys[name]
            return sys.intern(result) if result in common_keys else result
        
        # For any other key, intern if it's common
        return sys.intern(name) if name in common_keys else name

    def get_current_mode(self) -> str:
        """Determine current mode based on pressed keys with consistent ordering"""
        try:
            # 1. Check full sequence of pressed keys (including non-modifiers)
            if self.pressed_keys:
                full_sequence = '_'.join(self.pressed_keys)
                if full_sequence in self.config.get('modes', {}):
                    self.current_mode = full_sequence
                    logger.info(f"Active key sequence mode: {full_sequence}")
                    return full_sequence
            
            # 2. Check modifier-only sequence (only modifier keys in press order)
            modifier_sequence = [
                key for key in self.pressed_keys 
                if key in ['super', 'shift', 'alt', 'ctrl']
            ]
            if modifier_sequence:
                mode_name = '_'.join(modifier_sequence)
                if mode_name in self.config.get('modes', {}):
                    self.current_mode = mode_name
                    logger.info(f"Active modifier mode: {mode_name}")
                    return mode_name
            
            # Fallback to base mode if no special mode is active
            return 'base'
        except Exception as e:
            logger.error(f"Error determining current mode: {e}")
            return 'base'

    def update_lighting(self):
        """Update keyboard lighting based on current state - only redraw if needed"""
        try:
            # Create desired state (start with all black)
            desired_state = {}
            for r in range(self.rows):
                for c in range(self.cols):
                    desired_state[(r, c)] = (0, 0, 0)
            
            # Apply current mode with fallback
            current_mode = self.get_current_mode()
            mode_config = self.config.get('modes', {}).get(current_mode)
            
            # Fallback to base mode if current mode not defined
            if mode_config is None and current_mode != 'base':
                logger.info(f"Mode '{current_mode}' not defined, falling back to base")
                mode_config = self.config.get('modes', {}).get('base', {})
            
            # If still no config, use empty
            if mode_config is None:
                mode_config = {}
            
            logger.info(f"Applying lighting for mode: {current_mode}")
            
            # Apply all rules for the current mode to desired state
            for rule in mode_config.get('rules', []):
                self.apply_rule(rule, desired_state)
            
            # Check if any keys have changed
            needs_update = False
            for (row, col), color in desired_state.items():
                if self.current_key_states[row][col] != color:
                    needs_update = True
                    break
            
            # Only update if changes are detected
            if needs_update or self.need_redraw:
                # Clear keyboard (set all to black)
                for r in range(self.rows):
                    for c in range(self.cols):
                        self.razer_keyboard.fx.advanced.matrix[r, c] = (0, 0, 0)
                
                # Apply desired state
                for (row, col), color in desired_state.items():
                    try:
                        self.razer_keyboard.fx.advanced.matrix[row, col] = color
                        self.current_key_states[row][col] = color
                    except Exception as e:
                        logger.error(f"Error setting key at ({row}, {col}): {e}")
                
                # Draw changes
                self.razer_keyboard.fx.advanced.draw()
                logger.info("Keyboard redrawn due to changes")
                self.need_redraw = False
            else:
                logger.info("No changes detected, skipping redraw")
        except Exception as e:
            logger.error(f"Error updating lighting: {e}")
            logger.error(traceback.format_exc())
    
    def recv_fd(self, sock):
        """Receive a file descriptor from a Unix socket"""
        data, ancdata, flags, addr = sock.recvmsg(1, socket.CMSG_LEN(struct.calcsize('i')))
        for cmsg_level, cmsg_type, cmsg_data in ancdata:
            if cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SCM_RIGHTS:
                # Unpack the file descriptor from the ancillary data
                fd = struct.unpack('i', cmsg_data)[0]
                return fd
        return None

    def respond_to_challenge(self, conn, token):
        """Respond to authentication challenge"""
        try:
            # Wait for challenge with timeout
            ready = select.select([conn], [], [], 5.0)  # 5 second timeout
            if not ready[0]:
                raise RuntimeError("Timeout waiting for challenge")
                
            challenge = conn.recv(16)
            if not challenge or len(challenge) != 16:
                raise RuntimeError("Invalid challenge received")
            
            response = hmac.new(token, challenge, 'sha256').digest()
            conn.send(response)
        except Exception as e:
            logger.error(f"Error in challenge response: {e}")
            raise

    def connect_via_fd_passing(self):
        """Connect to the root process and receive the pipe file descriptor"""
        try:
            # Get the socket info from the protected file
            uid = os.getuid()
            socket_info_file = f"/run/user/{uid}/razer-keyboard/socket_info"
            
            # Wait for the file to be created with timeout
            timeout = 30  # 30 second timeout
            start_time = time.time()
            while time.time() - start_time < timeout:
                if os.path.exists(socket_info_file):
                    break
                time.sleep(0.1)
            else:
                raise RuntimeError("Socket info file not found. Is the root process running?")
            
            # Read the socket name, auth token, and expected executable hash
            with open(socket_info_file, 'r') as f:
                lines = f.read().splitlines()
                if len(lines) < 3:
                    raise RuntimeError("Invalid socket info file format")
                
                socket_name = lines[0].strip()
                auth_token_hex = lines[1].strip()
                expected_exe_hash = lines[2].strip()
            
            # Verify our script hash matches the expected one
            script_path = sys.argv[0]  # Path to this script
            with open(script_path, 'rb') as f:
                script_data = f.read()
                current_hash = hashlib.sha256(script_data).hexdigest()
            
            if current_hash != expected_exe_hash:
                raise RuntimeError(f"Script hash mismatch: {current_hash} != {expected_exe_hash}")
            
            # Decode the auth token
            try:
                auth_token = binascii.unhexlify(auth_token_hex)
            except:
                raise RuntimeError("Failed to decode authentication token")
            
            # Create abstract socket name
            abstract_name = f"\0razer_keyboard_{socket_name}"
            
            # Connect to the control socket with timeout
            control_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            control_socket.settimeout(10.0)  # 10 second timeout
            
            try:
                control_socket.connect(abstract_name)
            except socket.error as e:
                logger.error(f"Failed to connect to control socket: {e}")
                logger.error("This might mean the root process has already closed the socket after a connection")
                raise
            
            # Respond to authentication challenge with proper error handling
            try:
                # Wait for challenge with timeout
                ready = select.select([control_socket], [], [], 5.0)
                if not ready[0]:
                    raise RuntimeError("Timeout waiting for challenge")
                
                challenge = control_socket.recv(16)
                if not challenge or len(challenge) != 16:
                    raise RuntimeError("Invalid challenge received")
                
                response = hmac.new(auth_token, challenge, 'sha256').digest()
                control_socket.send(response)
            except Exception as e:
                control_socket.close()
                raise RuntimeError(f"Challenge response failed: {e}")
            
            # Receive the file descriptor
            self.pipe_fd = self.recv_fd(control_socket)
            control_socket.close()
            
            if self.pipe_fd is None:
                raise RuntimeError("Failed to receive file descriptor from root process")
            
            logger.info("Received pipe file descriptor from root process")
            
            # Start thread to read events
            self.pipe_thread = threading.Thread(target=self.read_pipe_events, daemon=True)
            self.pipe_thread.start()
            logger.info("Pipe reader thread started")
            
        except Exception as e:
            logger.error(f"Error connecting via FD passing: {e}")
            logger.error(traceback.format_exc())
            raise

    def read_pipe_events(self):
        """Read keyboard events from the pipe"""
        try:
            logger.info("Starting pipe reader thread")
            # Use bytes buffer instead of string buffer
            buffer = b""
            
            while self.pipe_fd:
                # Check if there's data to read
                r, _, _ = select.select([self.pipe_fd], [], [], 0.1)
                if not r:
                    continue
                
                try:
                    # Read data as bytes
                    data = os.read(self.pipe_fd, 4096)
                    
                    if not data:
                        logger.info("Pipe closed by writer")
                        break
                    
                    # Add to buffer and split into lines
                    buffer += data
                    lines = buffer.split(b'\n')
                    
                    # Process complete lines, keep incomplete in buffer
                    buffer = lines[-1]  # Last element might be incomplete
                    for line in lines[:-1]:
                        try:
                            # Decode only when needed
                            line_str = line.decode('utf-8')
                            event = json.loads(line_str)
                            
                            # Use cached/interned strings for event processing
                            event_type = self.get_cached_string(event['type'])
                            event_key = self.normalize_key_str(event['key'])
                            
                            if event_type == 'press':
                                self.on_press_str(event_key)
                            elif event_type == 'release':
                                self.on_release_str(event_key)
                        except (json.JSONDecodeError, UnicodeDecodeError):
                            logger.error(f"Invalid data: {line}")
                        except KeyError:
                            logger.error(f"Missing keys in event: {line}")
                        except Exception as e:
                            logger.error(f"Error processing event: {e}")
                    
                except BlockingIOError:
                    # No data available
                    pass
                except OSError as e:
                    if e.errno == 11:  # Resource temporarily unavailable
                        continue
                    else:
                        logger.error(f"OSError in pipe read: {e}")
                        break
                except Exception as e:
                    logger.error(f"Unexpected error in pipe read: {e}")
                    break
                
        except Exception as e:
            logger.error(f"Error in pipe reader: {e}")
            logger.error(traceback.format_exc())
        finally:
            if hasattr(self, 'pipe_fd') and self.pipe_fd:
                os.close(self.pipe_fd)
                self.pipe_fd = None

    def on_press_str(self, key_name: str):
        """Handle key press events from string"""
        try:
            key_identifier = self.normalize_key_str(key_name)
            
            logger.debug(f"KEY PRESS: {key_name} -> {key_identifier}")
            
            # Add to pressed keys if not already present
            if key_identifier not in self.pressed_keys:
                self.pressed_keys.append(key_identifier)
                logger.debug(f"Keys pressed: {list(self.pressed_keys)}")
            
            # Update lighting
            self.update_lighting()
            
            # Update workspaces when modifier state changes (only if integration enabled)
            if self.wm_integration_enabled and key_identifier in ['super', 'alt']:
                self.update_workspaces()
        except Exception as e:
            logger.error(f"Error in on_press: {e}")

    def on_release_str(self, key_name: str):
        """Handle key release events from string"""
        try:
            key_identifier = self.normalize_key_str(key_name)
            
            logger.debug(f"KEY RELEASE: {key_name} -> {key_identifier}")
            
            # Remove from pressed keys
            if key_identifier in self.pressed_keys:
                self.pressed_keys.remove(key_identifier)
                logger.debug(f"Keys pressed: {list(self.pressed_keys)}")
            
            # Update lighting
            self.update_lighting()
        except Exception as e:
            logger.error(f"Error in on_release: {e}")

    def listen_hyprland_events(self):
        """Listen for Hyprland workspace events"""
        try:
            # Get the Hyprland instance signature
            instance_sig = os.getenv('HYPRLAND_INSTANCE_SIGNATURE')
            if not instance_sig:
                logger.error("HYPRLAND_INSTANCE_SIGNATURE not set")
                return
                
            # Get XDG runtime directory
            xdg_runtime_dir = os.getenv('XDG_RUNTIME_DIR')
            if not xdg_runtime_dir:
                logger.error("XDG_RUNTIME_DIR not set, using fallback")
                xdg_runtime_dir = f"/run/user/{os.getuid()}"
                
            # Correct socket path using XDG_RUNTIME_DIR
            socket_path = os.path.join(xdg_runtime_dir, 'hypr', instance_sig, '.socket2.sock')
            
            if not os.path.exists(socket_path):
                logger.error(f"Hyprland socket not found at {socket_path}")
                return
                
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(socket_path)
            
            logger.info("Connected to Hyprland event socket")
                
            while True:
                # Check if we should stop
                if not self.wm_integration_enabled:
                    break
                    
                ready = select.select([sock], [], [], 1)
                if ready[0]:
                    data = sock.recv(4096)
                    if not data:
                        break
                        
                    event = data.decode().strip()
                    # Handle relevant events
                    if event.startswith(("workspace>>", "openwindow>>", "closewindow>>", "movewindow>>")):
                        logger.debug(f"Hyprland event: {event}")
                        self.update_workspaces()
                        self.update_lighting()
        except Exception as e:
            logger.error(f"Error in Hyprland listener: {e}")
        finally:
            try:
                sock.close()
            except:
                pass

    def start_wm_listener(self):
        """Listen for window manager events"""
        if not self.wm_integration_enabled:
            return
            
        try:
            if (self.wm_type == 'i3' or self.wm_type == 'sway') and I3_AVAILABLE:
                i3 = i3ipc.Connection()
                i3.on('window', self.on_wm_event)
                logger.info("Starting i3 event listener")
                i3.main()
            elif self.wm_type == 'hyprland':
                logger.info("Starting Hyprland event listener")
                self.listen_hyprland_events()
        except Exception as e:
            logger.error(f"Error in WM listener: {e}")

    def on_wm_event(self, i3, event):
        """Handle window manager events"""
        if not self.wm_integration_enabled:
            return
            
        try:
            if (self.wm_type == 'i3' or self.wm_type == 'sway'):
                if event.change in ['new', 'close', 'move']:
                    self.update_workspaces()
                    self.update_lighting()
        except Exception as e:
            logger.error(f"Error in WM event handler: {e}")

    def start_pywal_watcher(self):
        """Start watching pywal color file for changes"""
        pywal_path = os.path.expanduser('~/.cache/wal')
        if not os.path.exists(pywal_path):
            return
        
        pywal_event_handler = PywalFileHandler(self.handle_pywal_update)
        self.pywal_watchdog_observer = Observer()
        self.pywal_watchdog_observer.schedule(pywal_event_handler, pywal_path, recursive=False)
        self.pywal_watchdog_observer.start()
        logger.info(f"Started watching pywal colors at {pywal_path}")

    def start_config_watcher(self):
        """Start watching config file for changes"""
        config_path = os.path.expanduser('~/.config/razer-keyboard-highlighter')
        if not os.path.exists(config_path):
            os.makedirs(config_path, exist_ok=True)
            logger.info(f"Created config directory: {config_path}")
        
        config_event_handler = ConfigFileHandler(self.handle_config_update)
        self.config_watchdog_observer = Observer()
        self.config_watchdog_observer.schedule(config_event_handler, config_path, recursive=False)
        self.config_watchdog_observer.start()
        logger.info(f"Started watching config at {config_path}")

    def handle_pywal_update(self):
        """Called when pywal colors change - update lighting"""
        logger.info("Pywal colors updated - reloading")
        self.pywal_updated = True

    def handle_config_update(self):
        """Called when configs change - update lighting"""
        logger.info("Config updated - reloading")
        self.config_updated = True

    def reload_pywal_colors(self):
        """Reload colors and update lighting"""
        with self.colors_lock:
            self.colors = self.load_colors()
        self.pywal_updated = False
        # Force redraw after color reload
        self.need_redraw = True
        self.update_lighting()
        logger.info("Colors reloaded from pywal")

    def run(self):
        """Main application loop"""
        try:
            # Connect to the root process using FD passing
            self.connect_via_fd_passing()
            
            if self.wm_integration_enabled:
                self.update_workspaces()
                
                # Start WM listener thread only if enabled
                self.wm_thread = threading.Thread(target=self.start_wm_listener, daemon=True)
                self.wm_thread.start()
                logger.info(f"{self.wm_type} listener started")
            
            # Start pywal file watcher if enabled
            if self.config.get('pywal', True):
                self.start_pywal_watcher()
                logger.info("Pywal file watcher started")

            self.start_config_watcher()
            logger.info("Config file watcher started")
            
            # Apply initial lighting
            self.update_lighting()
            
            # Main loop
            logger.info("Entering main loop (Press Ctrl+C to exit)")
            while True:
                time.sleep(1)
                # Check for pywal updates
                if self.pywal_updated:
                    self.reload_pywal_colors()
                # Check for config updates
                if self.config_updated:
                    self.reload_config()
                
                # Periodically update workspaces only if integration enabled
                if self.wm_integration_enabled:
                    self.update_workspaces()
        except KeyboardInterrupt:
            logger.info("Exiting...")
            if hasattr(self, 'pipe_fd') and self.pipe_fd:
                os.close(self.pipe_fd)
                self.pipe_fd = None
            if self.pywal_watchdog_observer:
                self.pywal_watchdog_observer.stop()
                self.pywal_watchdog_observer.join()
            if self.config_watchdog_observer:
                self.config_watchdog_observer.stop()
                self.config_watchdog_observer.join()
            # Turn off keyboard lights
            try:
                for r in range(self.rows):
                    for c in range(self.cols):
                        self.razer_keyboard.fx.advanced.matrix[r, c] = (0, 0, 0)
                self.razer_keyboard.fx.advanced.draw()
            except:
                pass
        except Exception as e:
            logger.error(f"Error in main loop: {e}")
            logger.error(traceback.format_exc())

if __name__ == "__main__":
    try:
        controller = KeyboardController()
        controller.run()
    except Exception as e:
        logger.critical(f"Critical error: {e}")
        logger.critical(traceback.format_exc())
